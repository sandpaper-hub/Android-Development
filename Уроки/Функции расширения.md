В этом уроке мы познакомимся с ещё одной классной возможностью Kotlin — **функциями-расширениями**, на английском extension functions, extensions.

Kotlin позволяет расширять класс добавлением новых элементов без необходимости наследования от такого класса. Это реализовано с помощью специальных выражений, называемых **расширениями.**

Например, вы можете написать новые функции для класса из сторонней библиотеки, которую вы не можете изменить. Такие функции можно вызывать обычным способом будто методы исходного класса. Этот механизм называется функции-расширения.

Существуют и **свойства-расширения**, которые позволяют определять новые свойства для существующих классов.

Чтобы понять, как это работает, попробуем немного расширить класс `String`. Но для начала напишем функцию, которая разворачивает текст:

Скопировать кодKOTLIN

```
val text = "И да пребудет с тобой сила"

fun reverseString(str: String): String {
    val array = str.toCharArray() // конвертируем строку в массив символов Char
    var result = ""
    for (i in array.indices.reversed()) { // итерируемся по массиву в обратном направлении
        result += array[i]
    }
    return result
}

println(text)
println(reverseString(text)) 
```

Вывод:

Скопировать код

```
И да пребудет с тобой сила
алис йобот с тедуберп ад И 
```

Этот подход будет отлично работать. Мы можем даже поместить функцию `reverseString()` в какой-нибудь утилитарный класс и использовать её по всему приложению. В Java всегда так и делали.

Но мы же знаем, что Kotlin создан, чтобы делать код красивым.

![image](https://pictures.s3.yandex.net/resources/smotri_urok3_1659529095.png)

Вместо использования функции как функции стороннего объекта мы можем написать функции-расширения и использовать их, будто они реализованы внутри класса `String` без модификации самого класса `String`.

Скопировать кодKOTLIN

```
val text = "И да пребудет с тобой сила"

// функция reverse() стала функцией-расширением
fun String.reverse(): String {
    val array = toCharArray()
    var result = ""
    for (i in array.indices.reversed()) {
        result += array[i]
    }
    return result
}

println(text)
// теперь мы можем вызывать функцию reverse(), будто она является функцией класса String
println(text.reverse()) 
```

Вывод:

Скопировать код

```
// вывод остался прежним
И да пребудет с тобой сила
алис йобот с тедуберп ад И 
```

![](https://pictures.s3.yandex.net/resources/skhema_1664974276.png)

Чтобы написать функции-расширения, достаточно перед названием функции указать класс, который необходимо расширить. В нашем случае это класс `String`.

Во всём остальном эта функция подчиняется таким же правилам, как и любая другая функция в Kotlin.

Помните, в примере с функцией `reverseString()`, чтобы конвертировать строку в массив символов `Char`, мы использовали код `str.toCharArray()`, но в функции `reverse()` мы просто вызываем функцию `toCharArray()`.

Когда в функциях-расширениях мы указываем название класса перед названием функции, мы оказываемся внутри этого класса и можем вызывать внутри функций-расширений методы будто из функции внутри класса.

Получается, что внутри функций-расширений мы имеем доступы к внутренним полям и методам класса. И в примере с функцией `reverse()` мы просто вызываем функцию `toCharArray()`, потому что эта функция является частью класса `String`.

Мы могли бы это записать по-другому `this.toCharArray()`, это имело бы тот же эффект.

Не нарушаем ли мы так инкапсуляцию объекта?

Энди

Мы же можем обратиться к приватным членам класса, которые не должны попасть наружу!

Да, это хорошее замечание! Здесь кроется один важный момент, который нужно знать о функциях-расширениях.

Внутри таких методов мы можем обращаться только к тем членам класса, к которым можно обратиться в обычной функции. В нашем примере мы используем функцию `toCharArray()`, потому что у неё модификатор доступа `public`.

В то же время обратиться к переменным `hash` или `value` класса `String` мы не сможем, потому что они объявлены приватными.

Скопировать кодKOTLIN

```
fun String.printInternal() {
    println(toCharArray()) // toCharArray() — public, поэтому мы можем его использовать
    println("Длинна строки = $length") // length — public, потому что мы можем его использовать
//    println("hash = $hash") // этот код не будет скомпилирован, так как у нас нет доступа к переменной hash
//    println("hash = $value") // этот код не будет скомпилирован, так как у нас нет доступа к переменной value
}

text.printInternal() 
```

Вывод:

Скопировать код

```
И да пребудет с тобой сила
Длинна строки = 26 
```

Чтобы лучше понять такое поведение и то, как вообще работают функции-расширения, попробуем `декомпилировать` код метода `String.reverse()` в Java-код:

Скопировать кодJAVA

```
@NotNull
public static final String reverse(@NotNull String $this$reverse) {
    Intrinsics.checkNotNullParameter($this$reverse, "<this>");
    boolean var3 = false;
    char[] var10000 = $this$reverse.toCharArray();
    Intrinsics.checkNotNullExpressionValue(var10000, "(this as java.lang.String).toCharArray()");
    char[] array = var10000;
    String result = "";
    int var5 = array.length + -1;
    if (0 <= var5) {
        do {
            int i = var5--;
            result = Intrinsics.stringPlus(result, array[i]);
        } while(0 <= var5);
    }

    return result;
} 
```

Код трудночитаемый, но делает то же самое. Главное — это статический метод, который принимает на вход аргумент класса `String`.

Когда мы создаём функции-расширения, компилятор фактически создаёт статический `final`-метод, какой в качестве одного из аргументов принимает элемент класса, который мы хотим расширить.

И когда мы обращаемся к методам или полям расширяемого класса, компилятор вызывает их у этого аргумента. Обратите внимание на аргумент метода `$this$reverse` и его вызовы внутри функции.

Мы разобрались, как работают функции-расширения. Теперь разберём несколько нюансов при написании таких функций.

### Расширение null-допустимых типов

В Kotlin мы должны явно указывать типы, которые могут быть `null`. Что будет, если мы с вами попробуем использовать нашу функцию `String.reverse()` с null-допустимым типом?

Скопировать кодKOTLIN

```
val text: String? = null // null-допустимый тип

fun String.reverse(): String {
    val array = toCharArray()
    var result = ""
    for (i in array.indices.reversed()) {
        result += array[i]
    }
    return result
}

println(text.reverse()) // здесь будет получена ошибка компиляции  
```

При попытке скомпилировать такой код мы получим ошибку: `Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?`.

Скопировать кодKOTLIN

```
println(text?.reverse()) 
```

Мы можем использовать безопасный вызов `?.` функции `reverse()`. Но что если мы хотим, чтобы наша функция умела работать с `null` значениями. Например, мы бы могли возвращать развёрнутый `null` — `llun`.

Сделать это достаточно просто: после названия типа перед именем функции нужно указать `?`.

Скопировать кодKOTLIN

```
val text: String? = null

fun String?.reverse(): String {
    // мы можем проверить объект на null с помощью ключевого слова this
    if (this == null) return "llun"

    val array = toCharArray()
    var result = ""
    for (i in array.indices.reversed()) {
        result += array[i]
    }
    return result
}

println(text.reverse()) // теперь мы можем не использовать безопасный вызов. Наша функция умеет работать с null 
```

Вывод:

Скопировать код

```
llun 
```

### Свойства-расширения

Аналогично функциям Kotlin поддерживает расширения свойств.

Скопировать кодKOTLIN

```kotlin
val text: String = "И да пребудет с тобой сила"

val String.firstWord: String
    get() = this.split(" ")[0]

val String.lastWord: String
    get() {
        val wordsArray = this.split(" ")
        return wordsArray.get(wordsArray.size - 1)
    }

println(text.firstWord)
println(text.lastWord) 
```

Вывод:

Скопировать код

```
И
сила 
```

Расширения не изменяют существующий класс и не добавляют в него новые поля. Это значит, что расширения не могут содержать теневое поле. Поэтому запрещено использовать инициализаторы для свойств-расширений. Их поведение может быть определено только явным образом, с указанием геттеров/сеттеров.

Скопировать кодKOTLIN

```
// этот код не скомпилируется
// Extension property cannot be initialized because it has no backing field
val String.firstWorld: String = this.split(" ")[0] 
```

### Область видимости расширений

В большинстве случаев мы определяем расширения на верхнем уровне Kotlin файла (`<имя_файла>.kt`), непосредственно в разделе пакетов.

Скопировать кодKOTLIN

```
package com.practicum.yandex.stringext

fun String.reverse(): String { ... } 
```

Чтобы использовать такое расширение вне пакета, в котором оно было объявлено, импортируйте его на месте вызова.

Скопировать кодKOTLIN

```
package com.practicum.yandex.main

// импортируем функцию в месте вызова
import com.practicum.yandex.stringext.reverse

fun main() {
    val text = "И да пребудет с тобой сила"
    println(text.reverse())
} 
```

Расширения используют те же модификаторы видимости, как и обычные функции, объявленные в той же области видимости. Например:

- Расширение, объявленное на верхнем уровне файла, имеет доступ к другим `private` объявлениям верхнего уровня в том же файле.
- Если расширение объявлено вне своего типа приёмника, оно не может получить доступ к `private` или `protected` членам приёмника.