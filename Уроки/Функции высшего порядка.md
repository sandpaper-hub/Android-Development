В Kotlin все функции — **функции первого класса**. Они могут:

- Храниться в переменных и структурах данных.
- Передаваться в качестве аргументов.
- Возвращаться из других функций высшего порядка.

Можно работать с функциями любым способом, который возможен для других нефункциональных значений.

Kotlin как строго типизированный язык программирования использует семейство функциональных типов для представления функций и предоставляет набор специализированных языковых конструкций, таких как лямбда-выражение.

**Функция высшего порядка**, на английском top-level function, — это функция, которая принимает функции как параметры или возвращает функцию в качестве результата.

Из Java мы помним, что в метод можно передать только объекты и примитивы, но как функция может принимать другую функцию?

Рассмотрим простой пример. Есть задача, которая должна быть сделана, скажем, загрузка фотографий котиков из интернета. Наш код может выглядеть так:


```kotlin
fun main() {
    val catDownloader = CatDownloader()
    val newCat = catDownloader.downloadCat()
}

class CatDownloader {

    fun downloadCat(): Cat {
        // загружает фотографии котиков из интернета
    }
}

class Cat(val name: String) 
```

Иногда фотографии котиков не получается загрузить, потому что:

- Нет интернет-соединения;
- Нет нужных фотографий котиков;
- Или просто злые жуки съели сервер, и котики где-то застряли.

Мы, как настоящие профессионалы, **должны позаботиться о пользователях**. И если по каким-то причинам показать фотографии котиков пользователю не получается, то стоит ему об этом вежливо сообщить.

А значит, при загрузке фотографий котиков может быть два состояния:

- Фотография котика загружена успешно. Следовательно, показать котика пользователю.
- Фотография котика не смогла загрузиться. Следовательно, показать пользователю, что нам очень жаль.

Можем создать интерфейс с методами `onSuccess()` и `onError()`.

Да, это хорошее решение!

И если бы мы писали код на Java, то так бы и сделали. Только у этого решения есть недостаток. Задачи примитивного взаимодействия с пользователем попадаются часто, и нам придётся плодить много интерфейсов, большинство которых будут нужны лишь раз.

Kotlin позволяет избежать этого и передавать функции как аргументы. Мы можем переписать нашу функцию по загрузке фотографий котиков таким образом:

Скопировать кодKOTLIN

```kotlin
// передаем в аргументы функцию onSuccess
fun downloadCat(
    onSuccess: () -> Unit // выполнить при успешной загрузке фотографий котиков
) {
    // загружает фотографии котиков из интернета
} 
```

Давайте разбираться.

Наш аргумент состоит из трёх частей:

1. **имя функции** `onSuccess`. Это название нашего параметра. Оно может быть любым, но, как и с любой переменной, хорошо бы давать осмысленное название. Как и в любой переменной в Kotlin, после двоеточия `:` нужно указать тип аргумента. В нашем случае это функция, а как мы знаем, функция может что-то принимать и что-то возвращать.
2. **Аргументы функции** `()`. В круглых скобках можно перечислить через запятую список аргументов, которые должна принимать наша функция. В нашем случае скобки пустые, это значит, что функция ничего не принимает на вход.
3. **Возвращаемый тип** `Unit`. После стрелочки `->` нужно указать тип, который возвращает функция. В случае с обычными функциями можно опускать `Unit`, если функция ничего не возвращает, но если мы хотим передать функцию в аргументы, то нужно явно указать возвращаемый тип `Unit`.
    
    ![image](https://pictures.s3.yandex.net/resources/kod_2_urok2_1659525764.png)
    

Давайте добавим!

Доработайте код так, чтобы функция `downloadCat()` принимала на вход ещё и функцию `onError()`. Аргументы и возвращаемое значение функции `onError()` аналогичны функции `onSuccess`.

```kotlin
fun downloadCat (
	onSuccess: () -> Unit,
	onError: () -> Unit
)
```

Итак, как передать функцию в качестве аргумента, разобрались. Но в примере есть недостаток: функции не имеют никаких аргументов и ничего не возвращают. Значит, мы сможем сообщить, что фотография котика была загружена, но не сможем показать эту фотографию.

Давайте доработаем код так, чтобы функция `onSuccess()` умела передавать фотографию котика в аргументах. Для этого в скобках нужно передать тип аргументов, передаваемых в функции:

Скопировать кодKOTLIN

```kotlin
fun downloadCat(
    onSuccess: (cat: Cat) -> Unit, // теперь функция onSuccess принимает на вход один параметр типа Cat
) {
    // загружает фотографии котиков из интернета
} 
```

При указании типа в аргументах можно указывать имя переменной перед аргументом аналогично тому, как мы передаём обычные аргументы в функции. Такой подход может быть полезен, если непонятно для чего именно данный аргумент нужен из контекста. Или в ситуациях, когда у нас есть несколько аргументов одного типа.

Скопировать кодKOTLIN

```kotlin
fun downloadCat(
    onSuccess: (cat: Cat) -> Unit, 
    onError: () -> Unit
) {
    // загружает котиков из интернета
} 
```

Ошибки бывают разные, и хорошее приложение может по-разному реагировать на эти ошибки. Например:

- Если фотографии котиков не загрузились, потому что у пользователя нет интернета. В таком случае хорошо бы показать сообщение об отсутствии интернета и попробовать автоматически загрузить фотографии снова, когда соединение возобновится.
- Если фотографии котиков не загрузились, потому что какой-то джуниор разработчик или разработчица `уронили прод`, то нам бы стоило просто показать сообщение, что сейчас ведутся технические работы.

Для этого нам тоже нужно передать параметры в функцию `onError()`.

Доработайте код так, чтобы функция `onError()` принимала на вход аргумент c cообщением об ошибке типа `String`.

```kotlin
fun downloadCat(
    onSuccess: (cat: Cat) -> Unit, 
    onError: (error: String) -> Unit
) {
    // загружает котиков из интернета
} 
```

Отлично! Мы доработали нашу функцию `downloadCat()` и можем обрабатывать результат загрузки фотографий котиков.

Теперь нам нужно научиться работать с этими аргументами — как-то вызывать функции `onSuccess()` и `onError()` внутри функции `downloadCat()`.

Сделать это можно двумя способами:

1. Вызвать у переменной переданной функции метод `invoke()` и передать в него все аргументы, если такие имеются.
2. Использовать круглые скобки у переменной функции `()` и передать необходимые аргументы.

Оба способа абсолютно эквивалентны. Поэтому обычно способ вызова зависит только от договорённостей в команде разработки.

Оператор вызова (функции, метода) в круглых скобках транслируется в `invoke()` с соответствующим числом аргументов. Поговорим про операторы вызова в следующих уроках.

Скопировать кодKOTLIN

```kotlin
class CatDownloader {

    fun downloadCat(
        onSuccess: (Cat) -> Unit,
        onError: (String) -> Unit
    ) {
        val cat: Cat? = getCatFromInternet()

        if (cat != null) {
            onSuccess.invoke(cat) // вызываем функцию с помощью метода invoke() и передаём в нее объект cat
        } else {
            onError("Упс, что-то пошло не так при загрузке котеек.") // вызываем функцию, используя просто круглые скобки (), в которые передаём строку с сообщением
        }

    }

    // добавим немного случайности и имитируем ситуацию, когда фотография котика не может быть загружена
    private fun getCatFromInternet(): Cat? {
        return if (Random.nextBoolean()) Cat("Борис") else null
    }
} 
```

Итак, объявлять функции в параметрах и вызывать функции научились. Осталось наловчиться передавать их снаружи. Поскольку переданная функция — это всего лишь лямбда, здесь работают те же принципы.

Скопировать кодKOTLIN

```kotlin
fun main() {
    val catDownloader = CatDownloader()

    catDownloader.downloadCat(
        // используем именованные параметры, чтобы код был более понятен
        onSuccess = { cat -> println("Кот ${cat.name} загружен успешно") }, // в фигурных скобках указываем параметры и тот код, который должен выполниться при успешной загрузке фотографий котиков
        onError = { error -> println(error) } // в фигурных скобках указываем код, который выполнится в случае ошибки
    )
} 
```

Позапускайте код и посмотрите на результат. Можете поэкспериментировать с разными параметрами функций.

```kotlin
import kotlin.random.Random

fun main() {
    val catDownloader = CatDownloader()
    catDownloader.downloadCat(
        onSuccess = { cat -> println("Кот ${cat.name} загружен успешно") },
        onError = { error -> println(error) }
    )
}

class CatDownloader {

    // передаем в аргументы 2 функции onSuccess и onError
    fun downloadCat(
        onSuccess: (Cat) -> Unit,
        onError: (String) -> Unit
    ) {
        val cat: Cat? = getCatFromInternet()

        if (cat != null) {
            onSuccess.invoke(cat)
        } else {
            onError("Упс, что-то пошло не так при загрузке котеек.")
        }

    }

    private fun getCatFromInternet(): Cat? {
        return if (Random.nextBoolean()) Cat("Борис") else null
    }
}

class Cat(val name: String)
```

Отлично! Теперь мы знаем, что можем передавать функцию в аргументы другой функции.

Энди

Раз мы можем передать функцию в аргумент, то можем и хранить её в переменной?

Да, мы действительно можем хранить функцию в переменной как лямбда-выражение:

Скопировать кодKOTLIN

```kotlin
fun main() {
    val catDownloader = CatDownloader()
    // переменная объявляется по тому же принципу, что и передача функции в параметры другой функции.
    // сама функция объявляется в фигурных скобах { }
    val onSuccess: (Cat) -> Unit = { cat -> println("Кот ${cat.name} загружен успешно") }
    val onError: (String) -> Unit = { error -> println(error) }

    catDownloader.downloadCat(onSuccess = onSuccess, onError = onError)
} 
```

![](https://pictures.s3.yandex.net/resources/skhema_3_1664973743.png)

А раз мы можем функцию хранить в переменной, значит, можем и возвращать её из другой функции:

Скопировать кодKOTLIN

```kotlin
fun main() {
    val catDownloader = CatDownloader()
    val onSuccess: (Cat) -> Unit = doOnSuccess()
    val onError: (String) -> Unit = doOnError()
    catDownloader.downloadCat(onSuccess = onSuccess, onError = onError)
}
// явно указываем тип возвращаемой функции "(Cat) -> Unit"
private fun doOnSuccess(): (Cat) -> Unit = { cat -> println("Кот ${cat.name} загружен успешно") }
    
// Kotlin сам определит тип возвращаемой функции, но в этом случае внутри лямбда выражения необходимо явно указать тип аргументов "error: String"
private fun doOnError() = { error: String -> println(error) } 
```