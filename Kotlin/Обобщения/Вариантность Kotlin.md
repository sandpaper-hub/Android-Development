В kotlin обобщенные типы являются инвариантными. Это означает, что если у вас есть класс или интерфейс, параметризованный типом *`T`*, то экземпляр этого класса или интерфейса не является подтипом или супертипом для экземпляра с аргументом другого типа, даже если эти типы являются подтипами или супертипами друг друга.

```kotlin
class Box<T>(val value: T)

val intBox: Box<Int> = Box(42)
val anyBox: Box<Any> = intBox // Ошибка компиляции
```

Однако в _Kotlin_ существует возможность явно указать вариативность для обобщенных типов, используя ключевые слова *`in`* и *`out`*. Это делает типы ковариантными или контравариантными, в зависимости от указанного ключевого слова.

### Ковариантность
Ключевое слово **`out`** позволяет сделать обобщенный тип ковариантным.

```kotlin
interface Source<out T> {
    fun get(): T
}
```

Здесь **`T`** является ковариантным, что означает, что можно использовать подтипы `T`. Например, если **`String`** является подтипом **`Any`**, то **`Source<String>`** будет подтипом **`Source<Any>`.**

### Контрвариантность
Ключевое слов **`in`** позволяет сделать обобщенный тип котрвариантным.

```kotlin
interface Consumer<in T> {
    fun accept(value: T)
}
```

Здесь **`T`** является контравариантным, что означает, что можно использовать супертипы `T`. Например, если `Any` является супертипом **`String`**, то **`Consumer<Any>`** будет супертипом **`Consumer<String>`**.

Вариативность в Kotlin способствует более гибкому и безопасному использованию обобщений в языке, позволяя более точно указывать отношения между типами в контексте параметризованных типов данных.