Как и в Java, в Kotlin классы могут иметь типовые параметры.

```kotlin
class Box<T>(t: T) {
    var value = t
}
```

Для того чтобы создать объект такого класса, необходимо предоставить тип в качестве аргумента.

```kotlin
val box: Box<Int> = Box<Int>(1)
```

Но если параметры могут быть выведены из контекста (в аргументах конструктора или в некоторых других случаях), можно опустить указание типа.

```kotlin
val box = Box(1) // 1 имеет тип Int, поэтому компилятор отмечает для себя, что тип переменной box — Box<Int>
```

### Ограничения в обобщенных типах

Вместо ключевых слов `extends` и `implements` в kotlin используется двоеточие
```kotlin
class MailBox<T : Mail> {
    var mail : T? = null

    fun putMail(m: T) {
        mail = m
    }
}
```

Однако, если ограничений несколько, используется специальное ключевое слово `where` #ключеовое_слово
```kotlin
class MailBox<T> where T : Mail, T : Sendable {
    var mail : T? = null

    fun putMail(m: T) {
        mail = m
    }
}
```

После названия класса в угловых скобках указывается имя параметра типа. Если у данного параметра типа есть несколько ограничений, то после угловых скобок **нужно написать ключевое слово `where`**, за которым перечислить, от какого класса этот параметр должен наследоваться и какие интерфейсы реализовывать.

Если в Java при множественных ограничениях на первом месте в перечислении всегда должен находиться наследуемый класс, то в Kotlin такого правила нет, а ограничивающие классы и интерфейсы можно перечислять в любом порядке.

А если параметров типа несколько со своими ограничениями, то их можно указывать с использованием ключевого слова `where`, что довольно удобно:

```kotlin
class MailBox<T, S> where T : Mail, S : Sendable {
    …
} 
```

### Дженерик-конструкторы и функции

Перечисленные выше синтаксические правила справедливы и для дженерик-конструкторов, и для функций.

```kotlin
fun <E : Mail> fromArrayToList(array: Array<E>, list: ArrayList<E>) { 
	for (e in array) { 
		list.add(e) 
	}
}
```

В этом случае параметр типа у функции имеет всего одно ограничение, поэтому мы можем обойтись двоеточием. **Во множественных ограничениях** их нужно перечислять перед фигурными скобками с использованием ключевого слова `where`.

**Для дженерик-функций справедливо следующее:**

- Параметров типа может быть несколько и каждому можно задавать отдельные ограничения.
- Класс не обязан быть дженерик-классом, чтобы в нём могли быть дженерик-функции.
- Если класс обобщённый, то его имена параметров типа должны отличаться от имён параметров типа дженерик-функций этого класса.
- В классе может быть несколько дженерик-функций, и их имена параметров типа не обязательно должны отличаться, поскольку они имеют разные области видимости.

[[Вариантность Kotlin]]
[[Звёздная проекция]]
