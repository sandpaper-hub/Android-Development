В Kotlin **четыре модификатора доступа**:

- `private` означает видимость только внутри этого класса, включая его члены, как и в Java.
- `protected` то же самое, что и `private`, плюс возможность вызывать члены класса в его подклассах.

В Java модификатор `protected` разрешал обращаться к компонентам в пределах пакета и наследников. В Kotlin **решили от этого отказаться**, потому что переменные и методы, объявленные `protected`, используются только в пределах иерархии наследования. Более жёсткие ограничения позволяют совершать меньше ошибок.

- `public` — компонент с модификатором `public` виден всему приложению, как и в Java. В Kotlin модификатор `public` — **модификатор по умолчанию**, и если не указывать никакого модификатора, то компилятор подставит именно `public` модификатор.
- `internal` позволяет ограничить область видимости компонента в пределах модуля.

В Kotlin нет модификатора `package-private`, вместо него Kotlin предлагает модификатор `internal`, который позволяет добиться лучших результатов.

**Модуль** — это набор скомпилированных вместе файлов. В контексте Android-приложения: модуль — приложение, а проект (ваше Android-приложение) — контейнер для модулей.

Когда вы создаёте новое приложение, то IDE автоматически создаёт новый модуль для вашего приложения.

![[Pasted image 20231128222529.png]]

Простыми словами, это некоторая родительская папка для ваших файлов, которая может быть скомпилирована отдельно от остальных частей проекта. В проекте может быть неограниченное количество модулей:

![[Pasted image 20231128222551.png]]

Каждый модуль — это набор файлов, которые могут быть независимыми друг от друга и отдельно компилироваться в приложение, а могут работать вместе с другими модулями и компилироваться в одно приложение. Модули — это ещё один способ инкапсуляции, возможность разделить ваше приложение на мелкие компоненты, которые легче поддерживать по отдельности.

В маленьких приложениях часто все файлы лежат в одном модуле. Но когда приложение становится большим корпоративным приложением с множеством функций и экранов, то появляется необходимость разбивать приложение на части. Для этого есть несколько причин:

- Когда большое приложение разделено на части, **его легче поддерживать**. Например, в приложении для музыки может быть несколько модулей: модуль воспроизведения музыки, модуль текстов песен, модуль логики отрисовки виджета на рабочем столе. И каждый модуль легче поддерживать и чинить по отдельности.
- Модули можно **переиспользовать как в рамках одного приложения**, так и совершенно разных. Хорошим примером будет авторизация в приложении. Например, в продуктах Яндекса есть Яндекс-аккаунт, и его можно использовать для разных сервисов: музыки, кино, путешествий и прочего. Потому что логика авторизации была написана один раз и используется в каждом сервисе.
- Модульность позволяет тратить **меньше времени на сборку проекта**. Маленькое приложение компьютер скомпилирует за пару минут, но большие корпоративные приложения могут компилироваться больше часа. Когда приложение разбито на модули, это помогает системам сборки, таким как [Gradle](https://gradle.org/) (используется по умолчанию Android Studio для сборки проекта), ускорять сборку проекта благодаря разным оптимизациям.

`internal` позволяет ограничить доступ к файлам в пределах одного модуля: если какой-то класс будет объявлен в модуле `app`, то получить доступ к нему из модуля `feature-module` мы уже не сможем.

![[Pasted image 20231128222737.png]]

Если предположить, что класс `MainActivity` имеет модификатор `public`, а класс `BottomNavigationActivity` модификатор `internal`, то:

- Мы сможем вызвать класс `MainActivity` внутри класса `BottomNavigationActivity` или любого другого класса во всём проекте.
- Класс `BottomNavigationActivity` может быть вызван только в пределах модуля `feature-module`. Следовательно, вызвать `BottomNavigationActivity` внутри `MainActivity` не получится.

Этот модификатор доступа не подходит для проектов с одним модулем, только если не планируется создавать новые модули в будущем. В таких проектах модификатор `internal` ничем не будет отличаться от модификатора `public`.

В проектах с двумя и более модулями этот модификатор используется очень часто. Он позволяет сказать, какие компоненты должны быть доступны **только** в пределах модуля, а какие можно использовать во всём приложении. Это чем-то похоже на модификатор `private` внутри класса, только для целого модуля.

