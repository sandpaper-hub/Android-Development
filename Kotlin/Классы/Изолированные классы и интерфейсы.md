---
tags:
  - Kotlin
  - sealed
  - class
  - interface
---
Изолированные классы и интерфейсы позволяют выразить ограниченные иерархии классов, которые контролируют наследование. Во время компиляции известны все прямые наследники изолированного класса. Никакие другие наследники не могут появиться после компиляции модуля с изолированным классом.

Например, сторонние клиенты не могут расширить ваш изолированный класс в своём коде. Таким образом, каждый экземпляр изолированного класса имеет тип из ограниченного набора, который известен при компиляции этого класса.

Изолированные классы похожи на `enum`: набор значений `enum` типа также ограничен, но в отличие от `enum` наследник изолированного класса может иметь несколько экземпляров, которые хранят какое-то состояние. Чтобы описать изолированный класс или интерфейс, укажите модификатор `sealed` перед его именем:

```kotlin
sealed interface State  
```

После чего вы можете объявить классы, которые будут реализовывать ваш интерфейс:

```kotlin
sealed interface State {

    // каждый класс внутри sealed interface отражает отдельно состояние нашего экрана
    data class Data(val content: String) : State
    data class Error(val error: String) : State
    object Loading : State
} 
```

Объявлять реализации или классы-наследники `sealed` классов и интерфейсов совершенно необязательно внутри классов или интерфейсов, от которых они наследуются, но они должны быть объявлены в том же пакете.

**Ключевое преимущество** использования изолированных классов проявляется при работе с `when`. Если проверить, что выражение покрывает все случаи, то нам не нужно добавлять `else`.

Однако это работает только в том случае, если использовать `when` как выражение (используя результат), а не как оператор:

Скопировать кодKOTLIN

```
fun render(state: State) {
    when (state) {
        is State.Data -> println("Показываем контент: ${state.content}")
        is State.Error -> println("Показываем ошибку: ${state.error}")
        is State.Loading -> println("Показываем загрузку")
        // оператор `else` не требуется, потому что мы покрыли все возможные случаи
    }
} 
```

**Классы и интерфейсы** `sealed` очень похожи на обычное наследование, но имеют немного другое применение. Когда мы создаём обычный абстрактный класс или интерфейс, мы подразумеваем, что нам неизвестно, сколько будет наследников у супертипа.

**Классы и интерфейсы** `sealed` в использовании больше похожи на `enum` и применяются, когда нам необходимо строго ограничить количество наследников и важно знать их всех на стадии компиляции проекта.