```Kotlin
fun main() { // привычный нам public static void main(String[] args) из Java 
val a: Byte = -100 
val b: Short = 20 
val c: Int = -1 val 
d: Long = 30000 
}
```

Мы видим знакомый нам `main`. Метод `main`, который по умолчанию мы можем написать без указания параметров запуска программы, — ещё одна особенность языка Kotlin. Если вспомнить `public static void main(String[] args)` из Java, то там по умолчанию мы всегда должны передавать пустой массив строк на вход.

А вот в Kotlin, если для запуска нужны параметры, их можно указать так:

`fun main(args: Array<String>)`.

`Array` — массив строк, и мы обязательно поговорим о массивах в Kotlin в одном из следующих уроков.

Указываемый тип данных определяет, сколько памяти займёт данный объект и какие операции мы можем с ним делать.

Если мы напишем:

```Kotlin
   val a: Long = 5
   val b = a 
```

, то переменной `b` присвоится значение `5`, а её тип будет автоматически определён как `Long`. Компилятор поймёт это из контекста.

А если мы укажем тип переменной `b`, который будет отличаться от типа `a`, то IDE выдаст предупреждение, что операцию приведения типа нужно сделать явно:

```Kotlin
    val a: Int = 5
    val b: Long = a //при компиляции IDE выдаст ошибку Type mismatch: inferred type is Long but Int was expected
 
```

В Kotlin есть операторы для приведения типов `из коробки`: `toLong()`, `toInt()` и прочие, с помощью которых мы можем конвертировать значение переменных в нужный тип.

Как раз в этом случае нам помогает оператор приведения:

```Kotlin
    val a: Long = 5
    val b: Int = a.toInt() //код скомпилируется, значение b = 5
 
```

Часто необходимости в явных преобразованиях нет, поскольку тип выводится из контекста:

```Kotlin
    var aLong = 1L
    val b: Int = 4
    val c = aLong + b // Long + Int => Long
    println(c) // вывод: 5
 
```

Когда мы инициализируем **целочисленную** переменную без явного указания типа, компилятор автоматически выводит тип с наименьшим резервом памяти, достаточным для хранения значения.

Если значение не выходит за пределы диапазона `Int`, то оно расценивается как `Int`. Если значение превышает диапазон типа `Int`, то переменная, которой присваивается это значение, будет иметь тип `Long`.

Если при инициализации переменной присваиваемое значение не очень большое, но в будущем может увеличиться до `Long`, следует добавить к значению суффикс `L`.

**Явное указание типа** заставляет компилятор проверять, чтобы значение не выходило за пределы диапазона указанного типа.

Каждый численный тип поддерживает следующие преобразования:

```Kotlin
    toByte(): Byte
    toShort(): Short
    toInt(): Int
    toLong(): Long
    toFloat(): Float
    toDouble(): Double
 
```

**При приведении типов на уменьшение**, например, `Double` к `Int`, теряются знаки после запятой. Вся дробная часть числа будет отброшена без округления целой части.

```Kotlin
    val a: Double = 3.9
    val b: Int = a.toInt()
    println(b) // вывод: 3
 
```

Все переменные, указанные как целое значение, не превышающее максимальное для `Int`, автоматически будут определены как `Int`.

Если указанное значение превышает максимальное, то тип определится как `Long`. Вы можете явно указать тип `Long`, добавив после значения переменной литеру `L`:

```Kotlin
    val one = 1 // Int
    val oneLong = 1L // Long
 
```

Это же правило работает и для `Float`:

```Kotlin
    val one = 1 // Int
    val oneFloat = 1F // Float 
```

Можно инициализировать переменные `Double` и `Float` числами, имеющими дробную часть. Она должна быть отделена от целой части точкой `.` Для переменных, инициализированных дробными числами, компилятор автоматически определяет тип `Double`, если не указано иное.

```Kotlin
    val a = 3.0 // тип будет определён как `Double`
    val b: Double = 1 // ошибка приведения типов, нужно указать значение переменной 1.0 
```

Для улучшения читаемости можно отделять цифры с помощью символа `_`, например:

```Kotlin
    val a: Long = 1_000_000
    println(a) // вывод: 1000000 
```

Тип `Boolean`, как и в Java, может хранить только два значения: true или false. В Kotlin есть **заранее определённые операции для работы с `Boolean`**:

- `or` вместо `||` — логического ИЛИ.
- `and` вместо `&&` — логического И.
- `not` вместо `!` — отрицания.

```
    val a: Boolean = true
    
    val b: Boolean = !a // вывод: false
    val c: Boolean = a.not() // вывод: false
    
    val d: Boolean = a || b // вывод: true
    val e: Boolean = a or b // вывод: true
    
    val f: Boolean = a && b // вывод: false
    val g: Boolean = a and b // вывод: false
```

**Символы в Kotlin** представлены типом `Char`. Символьные литералы заключаются в одинарные кавычки: '1'. Если значение символьной переменной — цифра, её можно явно преобразовать в Int с помощью функции `digitToInt()`:

```Kotlin
    val a: Char = '5'
    val b = a.digitToInt() + 5
    println(b) // вывод: 10
 
```

Для проверки, является ли символ цифрой или буквой, используются функции `isDigit()` и `isLetter`:

```Kotlin
    val a: Char = '5'
    println(a.isLetter()) // вывод: false
    println(a.isDigit()) // вывод: true
```

Однако в Kotlin также есть тип Any, который позволяет присвоить переменной данного типа любое значение:

```Kotlin
fun main() {
    var name: Any = "Tom"
    println(name)   // Tom`
    name = 6758
    println(name)   // 6758`
}
```
