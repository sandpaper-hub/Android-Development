---
tags:
  - Kotlin
  - Array
---
В Kotlin массивы являются классами, которые могут хранить набор значений одного и того же типа. Они имеют типизацию подобно коллекциям в Java. Однако, в отличие от Java, чтобы иметь возможность хранить значение `null`, нужно явно указать нулабельность объекта.

```kotlin
var objects: Array<Any?> = arrayOfNulls(10) // массив Any на 10 элементов
var integers: Array<Int?> = arrayOfNulls(1) // массив int на 1 элемент
var strings: Array<String?> = arrayOfNulls(1000000) // массив строк String на 1000000 элементов
```

Конструктор массивов в Kotlin выглядит так:

`constructor(size: Int, init: (Int) -> T)`.

С первым полем всё понятно, оно указывает на размер массива. Но вот второе поле — лямбда-выражение, которое имеет в аргументах некоторый объект типа `Int` и возвращает обобщённый тип `T`.

Если последний параметр конструктора или функции является лямбда-выражением, то лямбда-выражение может быть вынесено за круглые скобки: `Array(5, { null })` <-> `Array(5) { null }`

```kotlin
// создаём массив, заполненный null
val nulls: Array<Any?> = Array(5) { null }

// создаём массив, заполненный значениями [индекс * 10]
val indexes: Array<Int> = Array(5) { index -> index * 10 }

// функция contentToString() — аналог статического метода Arrays.toString() из Java. 
// она позволяет вызвать у каждого элемента массива метод toString() в ситуациях, когда нужно отобразить массив в виде строки
println(nulls.contentToString()) 
println(indexes.contentToString()) 
```

Параметр `init` в конструкторе массива `Array` — это блок инициализации. Тут мы указываем, как хотим создать наш массив. Kotlin обязывает нас описать, как мы хотим создать массив.

С помощью встроенной функции arrayOf() можно передать набор значений, которые будут составлять массив:

```kotlin
	val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
```

С помощью индексов мы можем обратиться к определенному элементу в массиве. Индексация начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках.

```kotlin
	val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
	val n = numbers[1]
	numbers[2] = 7
	println("numbers[2] = ${numbers[2]}")
```

### Перебор массивов
Для перебора массивов можно применять цикл *for*

```kotlin
	val numbers = arrayOf(1, 2, 3, 4, 5)
	for(number in numbers) {
		println("$number")
	}
```

Аналогично можно перебирать массивы с помощью цикла *while*

```kotlin
	var i = 0
	while(i in people.indices){
		println(numbers[i])
		i++
	}
```

### Проверка наличия элемента в массиве

Как и в случае с последовательностью мы можем проверить наличие или отсутствие элементов в массиве с помощью операторов in и !in:

```kotlin
	val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
	println(4 in numbers)
```

### Массивы для базовых типов

Для упрощения создания массива в Kotlin определены дополнительные типы BooleanArray, ByteArray, ShortArray, IntArray, LongArray, CharArray, FloatArray и DoubleArray, которые позволяют создавать массивы для определенных типов. Например, тип `IntArray` позволяет определить массив объектов `Int`, а `DoubleArray` - массив объектов `Double`

```kotlin
	val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5)
	val doubles: DoubleArray = doubleArrayOf(2.4, 4.5, 1.2)
```

Для определения данных для этих массивов можно применять функции, которые начинаются на название типа в нижнем регистре, например, `int`, и затем идет `ArrayOf`

### Двухмерные массивы

Выше рассматривались одномерные массивы, которые можно представить в виде ряда или строки значений. Но кроме того, мы можем использовать многомерные массивы. К примеру, возьмем двухмерный массив - то есть такой массив, каждый элемент которого в свою очередь сам является массивом. Двухмерный массив еще можно представить в виде таблицы, где каждая строка - это отдельный массив, а ячейки строки - это элементы вложенного массива.

Определение двухмерных массивов менее интуитивно понятно и может вызывать сложности. Например, двухмерный массив чисел

```kotlin
	val table: Array<Array<Int>> = Array(3, { Array(5, {0})} )
```

В данном случае двухмерный массив будет иметь три элемента - три строки. Каждая строка будет иметь по пять элементов, каждый из которых равен 0.

Используя индексы, можно обращаться к подмассивам в подобном массиве, в том числе переустанавливать их значения

```kotlin
	val table = Array(3, { Array(3, {0})} )
	table[0] = arrayOf(1, 2, 3)
	table[1] = arrayOf(4, 5, 6)
	table[2] = arrayOf(7, 8, 9)
```

Для обращения к элементам подмассивов двухмерного массива необходимы два индекса. По первому индексу идет получение строки, а по второму индексу - столбца в рамках этой строки

```kotlin
	val table = Array(3, {Array(3, {0})} )
	table[0][1] = 6
	val n = table[0][1]
```

Для перебора такого массива потребуется два цикла.