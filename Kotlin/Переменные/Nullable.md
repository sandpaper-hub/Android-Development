Нулевая ссылка (от слова `null`) была изобретена Тони Хоаром, когда ему нужно было разработать систему типов для ссылок, и он «не смог устоять перед искушением указать нулевую ссылку из-за легкости её реализации».

Сейчас Тони Хоар называет изобретение `null` ошибкой на миллиард долларов. Ошибкой, которая привела к бесчисленным багам, уязвимостям и системным сбоям.

Всё-таки сам `null` не был ошибкой. Тони Хоар и другие эксперты информационных технологий подчёркивают, что ошибка именно в способе обработки `null` указателя.

Разработчики обязаны обрабатывать его, а язык должен заставлять нас это делать, и проверять это во время компиляции.

Иначе говоря, язык должен переводить ошибку `NullPointerException` со времени выполнения на время компиляции.

В Kotlin все типы бывают либо `nullable`, либо `non-nullable` — типы, которые могут быть пустыми и те, в которых всегда содержится значение.

Ключевое слово `null` представляет специальный литерал, который указывает, что переменная не имеет как такового значения. То есть у нее по сути отсутствует значение.
Однако переменным стандартных типов, например, типа Int или `String` или любых других классов, мы не можем просто взять и присвоить значение `null`:

```kotlin
val n: Int = null //! Ошибка, переменная типа Int допускает только числа
```

### ?
Для этого в Kotlin есть специальный символ `?`. Мы можем присвоить значение null только переменной, которая представляет тип Nullable. Чтобы превратить обычный тип в тип nullable, достаточно поставить после названия типа вопросительный знак:

```kotlin
val n: Int? = null // допускает null и числа
```

При этом мы можем передавать переменным nullable-типов как значение null, так и конкретные значения, которые укладываются в диапазон значений данного типа:

```kotlin
var age : Int? = null
age = 34              // Int? допускает null и числа`
var name : String? = null
name = "Tom"        // String? допускает null и строки`
```

В то же время надо понимать, что String? и Int? - это не то же самое, что и String и Int. Nullable типы имеют ряд ограничений:

- Значения nullable-типов нельзя присвоить напрямую переменным, которые не допускают значения null
```kotlin
var message : String? = "Hello"

val hello: String = message     // ! Ошибка - hello не допускает значение null`
```
- У объектов nullable-типов нельзя вызвать напрямую те же функции и свойства, которые есть у обычных типов
```kotlin
var message : String? = "Hello"
// у типа String свойство length возвращает длину строки
println("Message length: ${message.length}")    // ! Ошибка
```
- Нельзя передавать значения nullable-типов в качестве аргумента в функцию, где требуется конкретное значение, которое не может представлять null

### !!
Оператор !! (not-null assertion operator) принимает один операнд. Если операнд равен null, то генерируется исключение. Если операнд не равен null, то возвращается его значение.

```kotlin
fun main() {

    try {

        val name : String?  = "Tom"

        val id: String = name!!

        println(id)

    } catch (e: Exception) { println(e.message)}

}
```

Поскольку данный оператор возвращает объект, который не представляет nullable-тип, то после применения оператора мы можем обратиться к методам и свойствам этого объекта

### ?.
Оператор ?. позволяет объединить проверку значения объекта на null и обратиться к функциям или свойствам этого объекта.

Например, у строк есть свойство length, которое возвращает длину строки в символах. У объекта `String?` мы просто так не можем обратиться к свойству length, так как если объект `String?` равен null, то и строки как таковой нет, и соответственно длину строки нельзя определить. И в этом случае мы можем применить оператор ?.:

```kotlin
var message : String? = "Hello"
val length: Int? = message?.length
```
Если переменная `message` вдруг равна `null`, то переменная `length` получит значение `null`. Если переменная name содержит строку, то возвращается длина этой строки.

### ?:
Одним из преимуществ Kotlin состоит в том, что его система типов позволяет определять проблемы, связанные с использованием null, во время компиляции, а не во время выполнения.

Мы можем использовать оператор ?:, который позволяет предоставить альтернативное значение, если присваиваемое значение равно null:

```kotlin
var name : String?  = "Tom"
val userName: String = name ?: "Undefined"  // если name = null, то присваивается "Undefined"
var age: Int? = 23
val userAge: Int = age ?:0  // если age равно null, то присваивается число 0
```

Оператор ?: принимает два операнда. Если первый операнд не равен null, то возвращается значение первого операнда. Если первый операнд равен null, то возвращается значение второго операнда.

![[Nullable операторы.png]]