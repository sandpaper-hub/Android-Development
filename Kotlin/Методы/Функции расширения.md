Kotlin позволяет расширять класс путём добавления нового функционала без необходимости наследования от такого класса и использования паттернов, таких как _Decorator_. Это реализовано с помощью специальных выражений, называемых _расширения_.

Например, вы можете написать новые функции для класса из сторонней библиотеки, которую вы не можете изменить. Такие функции можно вызывать обычным способом, как если бы они были методами исходного класса. Этот механизм называется _функцией расширения_. Существуют также _свойства расширения_, которые позволяют определять новые свойства для существующих классов.

Для того чтобы объявить функцию-расширение, укажите в качестве префикса _расширяемый тип_, то есть тип, который мы расширяем. Следующий пример добавляет функцию `swap` к `MutableList<Int>`:

```kotlin
fun MutableList<Int>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' даёт ссылку на список
    this[index1] = this[index2]
    this[index2] = tmp
}
```

Ключевое слово `this` внутри функции-расширения соотносится с объектом расширяемого типа (этот тип ставится перед точкой). Теперь мы можем вызывать такую функцию в любом `MutableList<Int>`.

```kotlin
val list = mutableListOf(1, 2, 3)
list.swap(0, 2) // 'this' внутри 'swap()' будет содержать значение 'list'
```

Следующая функция имеет смысл для любого `MutableList<T>`, и вы можете сделать её обобщённой:

```kotlin
fun <T> MutableList<T>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' относится к списку
    this[index1] = this[index2]
    this[index2] = tmp
}
```

Вам нужно объявлять обобщённый тип-параметр перед именем функции для того, чтобы он был доступен в получаемом типе-выражении.

## Расширения вычисляются статически

Расширения на самом деле не проводят никаких модификаций с классами, которые они расширяют. Объявляя расширение, вы создаёте новую функцию, а не новый член класса. Такие функции могут быть вызваны через точку, применимо к конкретному типу.

Расширения имеют _статическую_ диспетчеризацию: это значит, что вызванная функция-расширение определяется типом её выражения, из которого она вызвана, а не типом выражения, вычисленным в ходе выполнения программы, как при вызове виртуальных функций.

```kotlin
open class Shape
class Rectangle: Shape()

fun Shape.getName() = "Shape"
fun Rectangle.getName() = "Rectangle"

fun printClassName(s: Shape) {
    println(s.getName())
}

printClassName(Rectangle())
```

Этот пример выведет нам _Shape_ на экран потому, что вызванная функция-расширение зависит только от объявленного параметризованного типа `s`, который является `Shape` классом.

Если в классе есть и функция-член, и функция-расширение с тем же возвращаемым типом, таким же именем и применяется с такими же аргументами, то _функция-член имеет более высокий приоритет_.

```kotlin
class Example {
    fun printFunctionType() { println("Class method") }
}

fun Example.printFunctionType() { println("Extension function") }

Example().printFunctionType()
```

Этот код выведет _Class method_.

Однако для функций-расширений совершенно нормально перегружать функции-члены, которые имеют такое же имя, но другую сигнатуру.

```kotlin
class Example {
    fun printFunctionType() { println("Class method") }
}

fun Example.printFunctionType(i: Int) { println("Extension function #$i") }

Example().printFunctionType(1)
```

Обращение к `Example().printFunctionType(1)` выведет на экран надпись _Extension function #1

## Свойства-расширения

Аналогично функциям, Kotlin поддерживает расширения свойств.

```kotlin
val <T> List<T>.lastIndex: Int
    get() = size - 1
```

> Поскольку расширения фактически не добавляют никаких членов к классам, свойство-расширение не может иметь [теневого поля](https://kotlinlang.ru/docs/properties.html#backing-fields). Вот почему _запрещено использовать инициализаторы для свойств-расширений_. Их поведение может быть определено только явным образом, с указанием геттеров/сеттеров.

Пример:

```kotlin
val House.number = 1 // ошибка: запрещено инициализировать значения
                     // в свойствах-расширениях
```

