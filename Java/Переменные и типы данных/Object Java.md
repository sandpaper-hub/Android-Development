**В Java всё является объектом.**

В языке Java определён один специальный класс `Object`. Все остальные классы являются подклассами, производными от класса `Object`.

Это означает, что класс `Object` служит суперклассом для всех остальных классов, и ссылочная переменная из класса `Object` может ссылаться на объект любого другого класса.

А поскольку массивы реализованы в виде классов, то ссылочная переменная типа `Object` может ссылаться и на любой массив.

```java
public static void main(String[] args) {
        Object text = "Hello Java"; 
        Object array = new int[10];
        Object bicycle = new Bicycle(); 
}
```

Этот код будет скомпилирован и будет корректно работать.

В классе `Object` есть несколько методов, и все они доступны для любого объекта.

Некоторые из них используются разработчиками часто, например, `equals()` и `hashCode()`, а некоторые в основном используются компонентами системы вроде `finalize()` или `notify()`.

Любой из этих методов можно вызвать в любом классе, даже если вы их там явно не определяли.

- `Object clone()` создаёт новый объект, не отличающийся от клонируемого.
- `void finalize()` вызывается перед удалением неиспользуемого объекта (не рекомендован для применения, начиная с версии JDK 9).
- `Class<?> getClass()` получает класс объекта во время выполнения.
- `void notify()` возобновляет исполнение потока, ожидающего вызывающего объекта.
- `void notifyAll()` возобновляет исполнение всех потоков, ожидающих вызывающий объект.
- `void wait()`, `void wait(long milliSeconds)` и `void wait(long milliSeconds, int nanoSeconds)` ожидают другого потока исполнения.
- `boolean equals(Object object)` определяет, равен ли один объект другому.
- `int hashCode()` возвращает хеш-код, связанный с вызывающим объектом.
- `String toString()` возвращает символьную строку, описывающую объект.

### String toString()

`String toString()` возвращает символьную строку, описывающую объект.
```java
class Person {

    final String name;
    final int age;

    public Person(final String name, final int age) {
        this.name = name;
        this.age = age;
    }
}

class Practicum {

    public static void main(String[] args) {
        Person kirill = new Person("Kirill", 25);
        System.out.println(kirill);
    }
}
```

Вывод будет таким: `Person@45c8e616`. Это не очень удобно, поэтому мы можем переопределить этот метод для более удобного вывода значения.

```java
class Person {

    final String name;
    final int age;

    public Person(final String name, final int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "'}";
    }
}
```

### boolean equals(Object object)

`boolean equals(Object object)` определяет, равен ли один объект другому. Когда мы хотим сравнить примитивные типы данных между собой, мы используем оператор `==`. Но этот оператор совершенно не подойдёт для ссылочных типов данных, потому что он сравнивает не сами объекты, а их ссылки:

```java
 public static void main(String[] args) {
        int a = 10;
        int b = 10;

        System.out.println(a == b); // true

        Person kirill = new Person("Kirill", 25);
        Person anotherKirill = new Person("Kirill", 25);

        System.out.println(kirill == anotherKirill); // false
}
```

Однако, если попробовать сравнить объекты с помощью метода `equals()`, результат также будет false

```java
public static void main(String[] args) {
        Person kirill = new Person("Kirill", 25);
        Person anotherKirill = new Person("Kirill", 25);

        System.out.println(kirill.equals(anotherKirill)); // false
}
```

Дело в том, что Java не знает каким образом мы хотим сравнить объекты. Поэтому мы сами должны реализовать метод `equals` так, как подразумеваем.

```java
class Person {

    final String name;
    final int age;

    public Person(final String name, final int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(final Object o) {
        // проверяем ссылки. Если они равны, то они указывают на один и тот же участок памяти, а значит, объекты точно эквивалентны между собой
        if (this == o) return true;

        // проверяем, что наш Object o действительно является объектом класса Person. Если это не так, то объекты точно не равны
        if (o != null && getClass() != o.getClass()) return false;

        // сравниваем поля. Если все поля равны, значит, и объекты эквивалентны друг другу
        final Person person = (Person) o;
        return age == person.age && name.equals(person.name);
    }
}
```

Очень важно при переопределении `equals()` придерживаться **основных правил, определённых в спецификации языка Java**:

- **Рефлексивность.** Для любого значения `x` выражение `x.equals(x)` всегда должно возвращать `true`.
- **Симметричность.** Для любых значений `x` и `y`, `x.equals(y)` должно возвращать `true` только в том случае, когда `y.equals(x)` возвращает `true`.
- **Транзитивность.** Для любых заданных значений `x`, `y` и `z`, если `x.equals(y)` возвращает `true` и `y.equals(z)` возвращает `true`, `x.equals(z)` должно вернуть значение `true`.
- **Согласованность.** Для любых заданных значений `x` и `y` повторный вызов `x.equals(y)` будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.
- **Сравнение `null`.** Для любого заданного значения `x` вызов `x.equals(null)` должен возвращать `false`.
### int hashCode()

`int hashCode()` возвращает хеш-код, связанный с вызывающим объектом.
**Хеш-функция** (в переводе с английского hash function от hash — превращать в фарш, мешанина) — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины, выполняемое определённым алгоритмом.

Преобразование, производимое хеш-функцией, называется хешированием. Исходные данные называются входным массивом, ключом или сообщением. **Результат преобразования называется хешем, хеш-кодом, хеш-суммой.**

Хеш-код применяется в следующих случаях:

- при построении ассоциативных массивов (например, HashMap)
- при поиске дубликатов в наборах данных;
- при построении уникальных идентификаторов для наборов данных.

Есть одно очень важное правило: **для двух равных объектов всегда будет равный хеш-код. Но равный хеш-код не всегда означает, что объекты равны**.

При генерации хеш-кода используется некоторый алгоритм, который высчитывает значение `int` в зависимости от значений полей объекта. Если объекты равны, то хеш-код всегда будет генерироваться одинаковый.

Но всегда существует вероятность того, что для двух разных объектов может быть создан одинаковый хеш-код.

### Контракт equals & hashCode

Методы `equals()` и `hashCode()` часто используются в паре для определения эквивалентности объектов. Иными словами, переопределяя метод `equals` всегда нужно переопределять метод `hashCode`, иначе возможны ситуации (в ассоциативных массивах), когда мы не сможем найти нужный объект по ключу.