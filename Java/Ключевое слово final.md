В Java смысл ключевого слова `final` зависит от контекста, но в основном оно означает "запрет на изменения".
Запрет на изменения может объясняться двумя причинами:
- архитектурой программы
- эффективностью

Ключевое слово `final` имеет три возможных применения.

### final классы

Объявляя класс неизменным — записывая в его определение ключевое слово `final`, вы показываете, что не собираетесь использовать этот класс в качестве базового при наследовании, и запрещаете это делать другим.

По какой-то причине структура вашего класса должна оставаться постоянной или же появление подклассов нежелательно.

```java
// класс KickScooter помечен ключевым словом final. Компилятор не позволит вам унаследоваться от него.
final class KickScooter extends Transport {

    @Override
    public void run() {
        System.out.println("Вжуууух!");
    }
    
    public void makeStunt() {
        System.out.println("Прыжок, с переворотом!");
    }
}

class ElectricScooter extends KickScooter { }
```
При попытке скомпилировать такой код вы получите ошибку `Cannot inherit from final 'KickScooter`.

### final методы

Неизменные `final` методы используются для **блокировки метода**, чтобы подклассы не могли изменить его поведение. Это делается, когда вам точно надо знать, что поведение метода не изменится при наследовании, как в ситуации с самокатами.

Любой `private` метод в классе косвенно является `final`. Так как вы не можете получить доступ к `private` методу, то вы не сможете его и переопределить. Вы можете добавить ключевое слово `final` к `private` методу, но это ни на что не повлияет.

### final переменные

Во многих языках программирования существует тот или иной способ сказать компилятору, что некоторая частица данных является **константой**.

Константа — это постоянная величина. Зачастую термин применяется в математике, физике или химии. Например, число pi, которое всегда равно 3.14...

Константа в программировании — способ адресации данных, изменение которых рассматриваемой программой не предполагается или запрещается.

**Константа времени компиляции** — это константа, которая может быть получена во времени компиляции, до запуска программы. Это число, которое не зависит от того, что будет происходить в программе.

Константы полезны в двух случаях:

#### как константа времени компиляции
В Java константы времени компиляции должны относиться к примитивным типам и строкам (класс `String`), а для их определения используется ключевое слово `final`.

Значение такой константы присваивается во время определения переменной.

Поле, одновременно объявленное с ключевыми словами `static` и `final`, существует в памяти в единственном экземпляре и не может быть изменено.

```java
// константы часто используются для определения ограниченного набора значений. 
// в данном примере мы как бы говорим: "Все поддерживаемые курсы валют есть в данном классе, если чего-то нет, значит, оно не поддерживается"
// есть и другие более ограниченные способы определять ограниченные наборы данных, но с ними мы с вами познакомимся позже на курсе
class Currencies {
    
    // в Java принято объявлять константы в верхнем регистре, а слова в имени разделять подчёркиванием
    public final static String RUBBLE = "RUB";
    public final static String AMERICAN_DOLLAR = "USD";
    public final static String AUSTRALIAN_DOLLAR = "AUD";
    public final static String EURO = "EUR";
}
```

#### как значение, инициализируемое во время работы программы, которое никогда не меняется.
При объявлении слова `final` со ссылками на объекты его смысл неочевиден. Для примитивов `final` делает неизменным значение переменной. После того как `final` ссылка будет указывать на объект, она больше не сможет указывать на другой объект, при этом сам объект может изменяться.

В Java нет механизмов, позволяющих сделать объект неизменным. Впрочем, ничего не мешает нам самим спроектировать класс так, чтобы его объекты были неизменными.

Массивы также относятся к ссылочным типам данных, и поэтому на них действуют эти же ограничения.
- **примитивы**
```java
int nonFinalPrimitive = 10; // изменяемая переменная. 
final int finalPrimitive = 10; // неизменяемая переменная

nonFinalPrimitive = 12; // этот код будет работать корректно
finalPrimitive = 12; // здесь компилятор выдаст ошибку "Cannot assign a value to final variable 'finalPrimitive'"
```

- **ссылочные типы данных**
```java
class Person {

    String name;
    int age;

    public Person(final String name, final int age) {
        this.name = name;
        this.age = age;
    }
}

class Praktikum {

    public static void main(String[] args) {
        Person kate = new Person("Kate", 18); // изменяемая переменная
        final Person ivan = new Person("Ivan", 23); // неизменяемая переменная

        printPerson(kate);
        printPerson(ivan);

        kate = new Person("Anna", 27); // этот код будет работать корректно
        // ivan = new Person("Petr", 19); // здесь мы получим ошибку компиляции "Сannot assign a value to final variable ivan"

        ivan.name = "Petr"; // а вот изменять сам объект мы можем
        ivan.age = 19;

        printPerson(kate);
        printPerson(ivan);
    }

    private static void printPerson(final Person person) {
        System.out.println("Person{" +
                "name='" + person.name + '\'' +
                ", age=" + person.age +
                '}');
    }
}
```

- **массивы**
```java
public static void main(String[] args) {
        int[] nonFinalArray = {1, 2, 3, 4, 5}; // изменяемая ссылка на массив
        final int[] finalArray = {1, 2, 3, 4, 5}; // неизменяемая ссылка на массив

        System.out.println(Arrays.toString(nonFinalArray));
        System.out.println(Arrays.toString(finalArray));

        nonFinalArray = new int[]{5, 6, 7}; // этот код будет работать корректно
        // finalArray = new int[]{5, 6, 7}; // здесь получим ошибку компиляции "Cannot assign a value to final variable 'finalArray'"

        for (int i = 0; i < finalArray.length; i++) {
            finalArray[i] = 0;
        }

        System.out.println(Arrays.toString(nonFinalArray));
        System.out.println(Arrays.toString(finalArray));
    }
```

В Java разрешается создавать пустые `final` поля, но такие поля **всегда должны быть иниализированы до первого использования**, и компилятор следит за этим

```java
final int value;
// System.out.println(value); // здесь будет ошибка "Variable 'value' might not have been initialized"
value = 12;
System.out.println(value); // а вот этот код отработает корректно, потому как выше мы присвоили значение 12
```

Неизменяемые объекты имеют **ряд преимуществ**:

- Они просты. Неизменяемый объект может находиться только в одном состоянии — в том, в котором он был создан.
- Они безопасны. Не стоит опасаться, что в процессе работы программы он как-то изменится неожиданным для вас образом. Особенно это будет актуально при работе с многопоточностью, но об этом мы поговорим в будущем.
- Их можно безопасно использовать везде. Один из простых приёмов, позволяющих достичь этого, — предоставление `public static final` констант для часто используемых значений. Вы можете безопасно использовать их откуда угодно и не думать о том, что какой-то другой компонент программы его изменит и сломает вашу логику.

**Основной недостаток** неизменяемых объектов — они требуют уникальный объект для каждого уникального значения. Если такой объект будет большим, он может потребовать большого количества ресурсов для создания нового экземпляра, что может негативно сказаться на скорости работы вашего приложения.