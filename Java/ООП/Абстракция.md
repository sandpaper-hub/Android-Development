В объектно-ориентированном программировании есть два понятия: **реализация и абстракция**.
Чтобы понять, в чём же между ними разница, попробуем найти проблемы в проектировании класса `Transport` и его наследников.

```java
class Transport {

    public void run() {
        System.out.println("Пум пурум пум - поехали");
    }
}

class Bicycle extends Transport {
    
    @Override
    public void run() {
        System.out.println("Я кручу, кручу, кручу педали.");
    }
}
```

1. Мы можем создавать класс `Transport`.

Давайте представим, что вы в реальной жизни занимаетесь проектированием велосипедов и самокатов. Да, все они могут ехать, но ведь каждый ездит по-разному. И если вас попросят создать транспорт, то задача будет не очень понятна.

Какой транспорт? Какими свойствами он должен обладать?

ООП нацелено на приближение проектирования программных компонентов к реальному миру. И когда мы говорим, что велосипед — это транспорт, то мы подразумеваем, что на нём можно доехать куда-то быстрее, чем пешком, или перевезти больше груза, чем на себе. Но нам всегда **нужна конкретика,** что же это за транспорт будет.

2. Мы можем не переопределять методы.

Тут важно понимать, что нам совершенно не обязательно всегда переопределять методы родительского класса. Это совершенно нормально, если в родительском классе есть логика, которая будет общей для всех его наследников.

Но что если нам принципиально важно, чтобы какой-то метод был переопределён в каждом классе?

Велосипед и электросамокат используют разные механизмы для езды, и мы не можем определить в базовом классе для них общее поведение.

Да, мы можем:

- Написать какую-то документацию и надеяться, что все её прочтут и не забудут сделать, что нужно для корректной работы компонента.
- Можем оставлять пустой метод в родительском классе и верить, что на него обратят внимание и переопределят этот метод.
- Можем даже создавать ошибку программы, чтобы у тех, кто забыл переопределить метод во время работы программы, был **crash — аварийное завершение программы**.

Но всё это похоже на какое-то плохое решение проектирования — **костыли**. В программировании **костыли — быстрое «уродливое» решение проблемы, иначе требующей долгосрочного и ресурсоёмкого исправления.**

Нам бы хотелось, чтобы мы могли сказать, что транспорт должен ехать. А вот как он будет ехать, должно зависеть от вида транспорта. И для решения данной проблемы у нас есть ключевое слово #abstract

Давайте решим первую проблему. Мы будем создавать класс `Transport`, потому что это обобщение, а не что-то конкретное:

```java
abstract class Transport { }

// Как и раньше, можем наследоваться от класса Transport
class Bicycle extends Transport { } 

class Practicum {

    public static void main(String[] args) {
        // мы можем создать объект Bicycle и присвоить его переменной Transport
        Transport bicycle = new Bicycle();
        // а вот создать объект класса Transport мы не можем. Мы получим ошибку компиляции — 'Transport' is abstract; cannot be instantiated
        Transport transport = new Transport(); 
    }
}
```